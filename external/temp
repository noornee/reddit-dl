package external

import (
	"fmt"
	"io/ioutil"
	"os"
	"strings"
	"time"

	"github.com/cavaliergopher/grab/v3"
	"github.com/noornee/reddit-dl/handler"
	"github.com/noornee/reddit-dl/utility"
	ffmpeg "github.com/u2takey/ffmpeg-go"
)

func Setup(media_url, audio_url, title string) {

	if audio_url != "" {
		status_code, mime := handler.GetHead(audio_url)

		if status_code == 200 && !strings.Contains(mime, "image") {
			downloader([]string{media_url, audio_url})
			video_merger(title)
			return
		}

	}

	downloader_nos(media_url)

}

// download files[video/gif/image](files with no sound) with aria2c
func downloader_nos(url string) {

	// create client
	client := grab.NewClient()

	req, _ := grab.NewRequest("", url)

	fmt.Printf("Downloading %v...\n", req.URL())

	resp := client.Do(req)

	//Start download
	fmt.Printf("  %v\n", resp.HTTPResponse.Status)

	// start UI loop
	t := time.NewTicker(500 * time.Millisecond)
	defer t.Stop()

Loop:
	for {
		select {
		case <-t.C:
			fmt.Printf("  transferred %v / %v bytes (%.2f%%)\n",
				resp.BytesComplete(),
				resp.Size(),
				100*resp.Progress())

		case <-resp.Done:
			// download is complete
			break Loop
		}
	}

	// check for errors
	if err := resp.Err(); err != nil {
		fmt.Fprintf(os.Stderr, "Download failed: %v\n", err)
		os.Exit(1)
	}

	fmt.Printf("Download saved to %v \n", resp.Filename)

}

func downloader(urls []string) {

	var temp_dir string = utility.CreateDir() + "/"

	// create client
	client := grab.NewClient()
	for _, url := range urls {

		req, _ := grab.NewRequest(temp_dir, url)

		fmt.Printf("Downloading %v...\n", req.URL())

		resp := client.Do(req)

		//Start download
		fmt.Printf("  %v\n", resp.HTTPResponse.Status)

		// start UI loop
		t := time.NewTicker(500 * time.Millisecond)
		defer t.Stop()

	Loop:
		for {
			select {
			case <-t.C:
				fmt.Printf("  transferred %v / %v bytes (%.2f%%)\n",
					resp.BytesComplete(),
					resp.Size(),
					100*resp.Progress())

			case <-resp.Done:
				// download is complete
				break Loop
			}
		}

		// check for errors
		if err := resp.Err(); err != nil {
			fmt.Fprintf(os.Stderr, "Download failed: %v\n", err)
			os.Exit(1)
		}

		fmt.Printf("Download saved to %v \n", resp.Filename)

	}

}

// merge downoladed files[video,audio] with ffmpeg
func video_merger(filename string) {

	const temp_dir = "temp/"

	filename = filename + ".mp4"

	files, err := ioutil.ReadDir(temp_dir)

	for i := range files {
		fmt.Println(files[i].Name())
	}
	if err != nil {
		utility.ErrorLog.Println(err)
	}

	var aud, vid string

	for range files {
		vid = temp_dir + files[0].Name()
		aud = temp_dir + files[1].Name()

	}

	in1 := ffmpeg.Input(vid)
	in2 := ffmpeg.Input(aud)

	utility.InfoLog.Printf("Merging files into \t%s", filename)
	fmt.Println()

	err = ffmpeg.Concat([]*ffmpeg.Stream{in1, in2}, ffmpeg.KwArgs{"v": 1, "a": 1}).
		Output(filename, ffmpeg.KwArgs{"v": "quiet"}).
		GlobalArgs("-stats").
		OverWriteOutput().ErrorToStdOut().Run()

	if err != nil {
		utility.ErrorLog.Println(err)
	}

	utility.InfoLog.Println("Done")

	err = os.RemoveAll(temp_dir)
	if err != nil {
		utility.ErrorLog.Println(err)
	}

}
